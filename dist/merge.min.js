const e=e=>Array.isArray(e),r=e=>(e=>null===e)(e)||t(e),t=e=>void 0===e,n=e=>i(e)&&"[object RegExp]"===c(e),i=e=>"object"==typeof e&&null!==e,o=e=>i(e)&&"[object Date]"===c(e),a=e=>e instanceof Buffer,c=e=>Object.prototype.toString.call(e).slice(8,-1);function s(e,t){if(e===t)return!0;if(a(e)&&a(t)){if(e.length!=t.length)return!1;for(var c=0;c<e.length;c++)if(e[c]!==t[c])return!1;return!0}return o(e)&&o(t)?e.getTime()===t.getTime():n(e)&&n(t)?e.source===t.source&&e.global===t.global&&e.multiline===t.multiline&&e.lastIndex===t.lastIndex&&e.ignoreCase===t.ignoreCase:i(e)||i(t)?function(e,t){var n,i,o,a;if(r(e)||r(t))return!1;if(e.prototype!==t.prototype)return!1;var c=u(e),l=u(t);if(c&&!l||!c&&l)return!1;if(c)return s(e=Array.prototype.slice.call(e),t=Array.prototype.slice.call(t));try{n=Object.keys(e),i=Object.keys(t)}catch(e){return!1}if(n.length!=i.length)return!1;for(n.sort(),i.sort(),a=n.length-1;a>=0;a--)if(n[a]!=i[a])return!1;for(a=n.length-1;a>=0;a--)if(!s(e[o=n[a]],t[o]))return!1;return!0}(e,t):e==t}function u(e){return"[object Arguments]"==Object.prototype.toString.call(e)}function l(e,...r){return f({},e,...r)}function f(e,r,...t){const n={...e,_visited:[]};return t.reduce(((e,r)=>p(n,e,r)),r)}function p(r,t,n){let o,a,u,f,y;if(r._visited||(r._visited=[]),t===n||void 0===n)return t;if(null===n)return r.ignoreNull&&void 0!==t||(t=n),t;if(null==t)return p(r,e(n)?[]:{},n);const b=c(n);switch(b){case"RegExp":return new RegExp(n,n.flags);case"Date":return new Date(n);case"Int8Array":case"Uint8Array":case"Uint8ClampedArray":case"Int16Array":case"Uint16Array":case"Int32Array":case"Uint32Array":case"Float32Array":case"Float64Array":case"BigInt64Array":case"BigUint64Array":return globalThis[b].from(n);case"ArrayBuffer":case"SharedArrayBuffer":return new globalThis[b](n);case"Map":if(t instanceof Map)for(y of n.keys())(t=new Map(t)).set(y,l(t.get(y),n.get(y)));else t=new Map(n);return t;case"Set":return t=(e=>e instanceof Set)(t)?new Set(t).union(n):new Set(n),t;case"Error":const c=new Error(n.message);return Object.defineProperties(c,Object.getOwnPropertyDescriptors(n)),c;case"Function":{const e=function(...e){return n(...e)};return Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)),e}case"Array":if(e(t)){const e=[...t];for(o=0;o<n.length;o++)if(u=n[o],!~e.indexOf(u))if(i(u)&&null!==u){for(f=!1,a=e.length;a-- >0&&!(f=s(e[a],u)););f||t.push(p(r,null,u))}else t.push(u)}else t=p(r,[],n);return t;case"Object":if(!i(t)&&!(e=>"function"==typeof e)(t))return n;if(~r._visited.indexOf(n)){if(!r.ignoreCircular)throw new Error("can not merge circular structures.")}else{for(y in r._visited.push(n),n)g(t,y)||(t[y]=p(r,t[y],n[y]));r._visited.pop()}return t;default:return n}}const g=(e,r)=>r in e&&(!Object.hasOwnProperty.call(e,r)||!Object.propertyIsEnumerable.call(e,r));export{p as _merge,l as merge,f as mergeExt};
